import {
  app,
  net,
  BrowserWindow,
  autoUpdater,
  ipcMain,
  shell,
  dialog,
  powerMonitor,
} from 'electron';
import path from 'path';
import url from 'url';
import log from 'electron-log';
import installExtension, { REACT_DEVELOPER_TOOLS } from 'electron-devtools-installer';
import { getLastUser, getAppBounds, setAppBounds, sqliteEvents } from './services/sqlite';
import { capture } from './services/analytics';
import { isDev, isTesting, logger } from './utils';
import { serializeError } from 'serialize-error';

require('./services/mdx');
require('./services/saveFile');

let openUrl = '';

if (process.defaultApp) {
  if (process.argv.length >= 2) {
    app.setAsDefaultProtocolClient('journal', process.execPath, [path.resolve(process.argv[1])]);
  }
} else {
  app.setAsDefaultProtocolClient('journal');
}

// This allows TypeScript to pick up the magic constant that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Env
// process.env.NODE_ENV = 'development'

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  // eslint-disable-line global-require
  app.quit();
}

const createWindow = (): void => {
  // Create the browser window.
  const bounds = getAppBounds(1200, 800);
  const mainWindow = new BrowserWindow({
    ...bounds,
    minWidth: 400,
    minHeight: 300,
    titleBarStyle: 'customButtonsOnHover',
    trafficLightPosition: { x: 16, y: 16 },
    show: false,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      sandbox: true,
      spellcheck: true,
    },
  });

  ipcMain.on('electron-reload', async () => {
    mainWindow.reload();
  });

  mainWindow.on('resized', () => {
    logger('resized');
    setAppBounds(mainWindow.getBounds());
    capture({
      distinctId: getLastUser(),
      event: 'app resized',
      properties: mainWindow.getBounds(),
    });
  });

  mainWindow.on('moved', () => {
    logger('moved');
    setAppBounds(mainWindow.getBounds());
  });

  mainWindow.on('maximize', () => {
    logger('maximize');
    capture({
      distinctId: getLastUser(),
      event: 'app maximize',
    });
  });

  mainWindow.on('minimize', () => {
    logger('minimize');
    capture({
      distinctId: getLastUser(),
      event: 'app minimize',
    });
  });

  mainWindow.on('enter-full-screen', () => {
    logger('enter-full-screen');
    capture({
      distinctId: getLastUser(),
      event: 'app enter-full-screen',
    });
  });

  // Session time
  let start: [number, number];
  let sessionActive = false;
  mainWindow.on('focus', () => {
    start = process.hrtime();
    sessionActive = true;
    logger('Focus');
  });
  mainWindow.on('blur', () => {
    logger('Blur');
    const sessionTime = process.hrtime(start)[0];
    sessionActive = false;
    logger(`Session: ${sessionTime} seconds`);
    capture({
      distinctId: getLastUser(),
      event: 'session',
      properties: { sessionTime },
    });
  });

  mainWindow.on('close', () => {
    logger('Close');
    capture({
      distinctId: getLastUser(),
      event: 'app window close',
    });
    if (sessionActive) {
      const sessionTime = process.hrtime(start)[0];
      logger(`Session: ${sessionTime} seconds`);
      capture({
        distinctId: getLastUser(),
        event: 'session',
        properties: { sessionTime },
      });
    }
  });

  mainWindow.once('ready-to-show', () => {
    mainWindow.show();

    capture({
      distinctId: getLastUser(),
      event: 'app launched',
    });

    // Handle open from url when app was closed
    if (openUrl) {
      mainWindow.webContents.send('open-url', openUrl);
      capture({
        distinctId: getLastUser(),
        event: 'app open-from-url',
      });
      openUrl = '';
    }
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  if (isDev() && !isTesting()) {
    mainWindow.webContents.openDevTools();
    installExtension(REACT_DEVELOPER_TOOLS)
      .then((name) => console.log(`Added Extension:  ${name}`))
      .catch((err) => console.log('An error occurred: ', err));
  }

  ipcMain.removeHandler('electron-disableSpellCheck');
  ipcMain.handle('electron-disableSpellCheck', async () => {
    logger('electron-disableSpellCheck');
    mainWindow.webContents.session.setSpellCheckerLanguages([]);
  });

  ipcMain.removeHandler('electron-enableSpellCheck');
  ipcMain.handle('electron-enableSpellCheck', async () => {
    logger('electron-enableSpellCheck');
    mainWindow.webContents.session.setSpellCheckerLanguages(
      mainWindow.webContents.session.availableSpellCheckerLanguages,
    );
  });

  mainWindow.webContents.on('context-menu', (_event: any, params: unknown) => {
    logger('context-menu event');

    mainWindow.webContents.send('electron-handleSpellCheck', params);
    // const menu = new Menu()

    // // Add each spelling suggestion
    // for (const suggestion of params.dictionarySuggestions) {
    //   menu.append(
    //     new MenuItem({
    //       label: suggestion,
    //       click: () => mainWindow.webContents.replaceMisspelling(suggestion),
    //     })
    //   )
    // }

    // // Allow users to add the misspelled word to the dictionary
    // if (params.misspelledWord) {
    //   menu.append(
    //     new MenuItem({
    //       label: 'Add to dictionary',
    //       click: () =>
    //         mainWindow.webContents.session.addWordToSpellCheckerDictionary(params.misspelledWord),
    //     })
    //   )
    // }

    // menu.popup()
  });
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  app.quit();
});

app.on('before-quit', () => {
  logger('before-quit');
  capture({
    distinctId: getLastUser(),
    event: 'app close',
  });
});

app.on('before-quit', () => {
  logger('quit');
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Handle the protocol
app.on('open-url', (event, url) => {
  const win = BrowserWindow.getAllWindows()[0];
  if (win) {
    // Handle open from url when app is opened
    win.webContents.send('open-url', url);
  } else {
    // If app is closed/no windows, save url for when app opens
    openUrl = url;
  }
});

// Open links in the browser
app.on('web-contents-created', (_event, contents) => {
  contents.on('will-navigate', (event, navigationUrl) => {
    const parsedUrl = new url.URL(navigationUrl);
    const isDev = parsedUrl.host == 'localhost:3000';
    if (!isDev && ['https:', 'http:', 'mailto:'].includes(parsedUrl.protocol)) {
      event.preventDefault();
      shell.openExternal(navigationUrl);
    }
  });
  contents.setWindowOpenHandler(() => {
    return { action: 'deny' };
  });
});

// app.commandLine.appendSwitch('ignore-certificate-errors')

process.on('uncaughtException', (error) => {
  logger('uncaughtException');
  logger(error);
  log.error(error);
  if (!isDev()) {
    capture({
      type: 'error',
      distinctId: getLastUser(),
      event: 'error uncaughtException',
      properties: serializeError(error),
    });
  }
});

ipcMain.on('is-testing', function (event) {
  event.returnValue = process.argv.includes('testing');
});

ipcMain.on('power-monitor-idle-state', function (event) {
  event.returnValue = powerMonitor.getSystemIdleState(100);
});

ipcMain.on('net-is-online', function (event) {
  event.returnValue = net.isOnline();
});

// Time simulation in testing only
if (process.argv.includes('testing')) {
  ipcMain.on('test-set-date', function (_, date: Date) {
    const win = BrowserWindow.getAllWindows()[0];
    win.webContents.send('test-set-date', date);

    // Create a new class that extends Date
    class TestDate extends Date {
      constructor(...args: any[]) {
        if (args.length === 0) {
          super(date);
        } else {
          // @ts-expect-error replacing ignore
          super(...args);
        }
      }

      static now() {
        return Date.now() + (date.getTime() - Date.now());
      }

      static parse(s: string) {
        return Date.parse(s);
      }

      static UTC(...args: any[]) {
        // @ts-expect-error replacing ignore
        return Date.UTC(...args);
      }

      static readonly [Symbol.species] = Date;
    }

    // Use the new TestDate class in your tests
    (global as any).TestDate = TestDate;
  });
}

powerMonitor.on('resume', () => {
  logger('Resume from sleep');
  const win = BrowserWindow.getAllWindows()[0];
  win.webContents.send('power-monitor-resume');
});

// Handle events from SQLIte
sqliteEvents.on('sqlite-entry-event', () => {
  const win = BrowserWindow.getAllWindows()[0];
  win.webContents.send('sqlite-entry-event');
});
sqliteEvents.on('sqlite-tag-event', () => {
  const win = BrowserWindow.getAllWindows()[0];
  win.webContents.send('sqlite-tag-event');
});

// Handle Update downloaded
autoUpdater.on('update-downloaded', () => {
  logger('update-downloaded');
  log.info('update-downloaded');
  const win = BrowserWindow.getAllWindows()[0];
  if (win) win.webContents.send('update-downloaded');
});

// Handle errors
autoUpdater.on('error', (error: Error & { domain: string; code: number }) => {
  logger('Error:');
  logger(error);
  log.info('Error:');
  log.info(error);
  capture({
    type: 'error',
    distinctId: getLastUser(),
    event: 'error auto-updater',
    properties: serializeError(error),
  });
  if (error?.domain == 'SQRLUpdaterErrorDomain' && error?.code == 8) {
    logger('Read-only volume');
    log.info('Read-only volume');
    dialog.showMessageBoxSync({
      message:
        "You've launched Journal on a read-only volume. Please move Journal to Applications folder and try again.",
      title: 'read-only volume',
      type: 'warning',
    });
    app.quit();
  }
});

// Rest of autoUpdate logic
require('./services/autoUpdater');

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
